import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import seaborn as sns
from matplotlib.font_manager import FontProperties
import os
import argparse
from typing import Dict, Any, List, Union, Tuple


# Function to format y-axis ticks
def format_ticks_adjusted(value: Union[int, float], pos: Any) -> str:
    """
    Formats y-axis tick values for better readability (e.g., 1000000 as 1M, 1000 as 1k).

    Parameters
    ----------
    value : Union[int, float]
        The tick value.
    pos : Any
        The position of the tick (unused but required by FuncFormatter).

    Returns
    -------
    str
        The formatted tick string.
    """
    if value >= 1_000_000:
        return f"{int(value/1_000_000)}M"
    elif value >= 1_000:
        return f"{int(value/1_000)}k"
    else:
        return str(int(value))  # Ensure integer for values < 1000


def generate_plots(
    metrics_df: pd.DataFrame, output_dir: str, dataset_name: str
) -> None:
    """
    Generates and saves two sets of plots from network metrics:
    1. Number of Nodes and Edges vs. Threshold.
    2. Number of Communities, Average Degree, Modularity, and Average Clustering Coefficient vs. Threshold.

    Parameters
    ----------
    metrics_df : pd.DataFrame
        The DataFrame containing network metrics, typically generated by the network analysis script.
        Expected columns include 'Threshold', 'Nodes', 'Edges', 'Number_communities',
        'Avg_degree', 'Modularity', 'Avg_clustering_coefficient', and 'Dataset' (or 'Biome').
    output_dir : str
        The directory where the generated plots (PNG and SVG) will be saved.
    dataset_name : str
        The name of the dataset/biome for naming output files. This name should reflect
        the network type and weight column if those distinctions are needed in the filename.

    Returns
    -------
    None
        Plots are saved to the specified `output_dir`.
    """

    # Ensure output directory exists
    os.makedirs(output_dir, exist_ok=True)

    # Filter out rows with inconsistent messages
    # Create a copy to avoid SettingWithCopyWarning
    filtered_metrics = metrics_df[
        ~metrics_df.eq("Network too small (<= 3 edges)").any(axis=1)
    ].copy()
    filtered_metrics = filtered_metrics[
        ~filtered_metrics.eq("No network available").any(axis=1)
    ].copy()

    # Rename 'Dataset' to 'Biome' if it exists for consistency with original script's plotting
    if (
        "Dataset" in filtered_metrics.columns
        and "Biome" not in filtered_metrics.columns
    ):
        filtered_metrics.rename(columns={"Dataset": "Biome"}, inplace=True)

    # Convert 'Threshold' column to numeric
    filtered_metrics["Threshold"] = pd.to_numeric(
        filtered_metrics["Threshold"], errors="coerce"
    )
    # Drop rows where 'Threshold' became NaN due to coercion errors (if any)
    filtered_metrics.dropna(subset=["Threshold"], inplace=True)

    # Set the aesthetic style of the plots
    sns.set_style("whitegrid")

    # Font size configuration
    axis_label_font_size = 20
    tick_label_font_size = 18
    legend_font_size = 20

    # Ensure 'Biome' column exists for palette and legend creation
    if "Biome" not in filtered_metrics.columns:
        print(
            "Warning: 'Biome' column not found, defaulting to a single color palette."
        )
        palette = ["#4C72B0"]  # A single default color
        filtered_metrics["Biome"] = "Default"  # Add a dummy biome if missing
    else:
        # Choose a varied color palette based on unique biomes
        palette = sns.color_palette(
            "husl", n_colors=len(filtered_metrics["Biome"].unique())
        )

    # Determine the range for x-axis ticks
    if not filtered_metrics["Threshold"].empty:
        x_min = min(filtered_metrics["Threshold"])
        x_max = max(filtered_metrics["Threshold"])
        x_ticks = np.arange(
            x_min, x_max + 0.05, 0.1
        )  # Adjusted upper bound for np.arange
    else:
        x_ticks = []  # No ticks if no data

    # --- Plotting Nodes and Edges ---
    metrics_nodes_edges = ["Nodes", "Edges"]
    metric_name_mapping_nodes_edges = {
        "Nodes": "Number of Nodes",
        "Edges": "Number of Edges",
    }
    metrics_needing_formatting = ["Nodes", "Edges"]  # For Y-axis formatting

    fig1, axes1 = plt.subplots(nrows=1, ncols=2, figsize=(20, 10))

    for i, metric in enumerate(metrics_nodes_edges):
        ax = axes1.flatten()[i]
        for biome in filtered_metrics["Biome"].unique():
            sns.lineplot(
                ax=ax,
                x="Threshold",
                y=metric,
                data=filtered_metrics[filtered_metrics["Biome"] == biome],
                marker="o",
                markersize=9,
                linewidth=2.5,
                color=(
                    palette[filtered_metrics["Biome"].unique().tolist().index(biome)]
                    if len(palette) > 1
                    else palette[0]
                ),
            )
        ax.set_ylabel(
            metric_name_mapping_nodes_edges[metric], fontsize=axis_label_font_size
        )
        ax.set_xlabel("Association Threshold", fontsize=axis_label_font_size)
        ax.tick_params(axis="both", labelsize=tick_label_font_size)
        ax.set_xticks(x_ticks)

        if metric in metrics_needing_formatting:
            ax.yaxis.set_major_formatter(ticker.FuncFormatter(format_ticks_adjusted))

    # Creating legend handles for Nodes/Edges plot
    legend_handles_1 = []
    for biome in filtered_metrics["Biome"].unique():
        line = plt.Line2D(
            [],
            [],
            color=(
                palette[filtered_metrics["Biome"].unique().tolist().index(biome)]
                if len(palette) > 1
                else palette[0]
            ),
            marker="o",
            markersize=10,
            linestyle="-",
            linewidth=3,
            label=biome,
        )
        legend_handles_1.append(line)

    title_font = FontProperties(weight="bold", size=legend_font_size)

    fig1.legend(
        handles=legend_handles_1,
        loc="upper center",
        title="Biome",
        ncol=len(
            filtered_metrics["Biome"].unique()
        ),  # Adjust ncol based on number of biomes
        bbox_to_anchor=(0.5, 1),
        fontsize=legend_font_size,
        title_fontproperties=title_font,
    )

    plt.tight_layout(rect=[0, 0, 1, 0.9])  # Adjusted rect to make space for title

    # Saving the Nodes/Edges plots - filenames now rely only on dataset_name
    fig1_output_name = f"{dataset_name}_nodes_edges.png"
    fig1_output_path_png = os.path.join(output_dir, fig1_output_name)
    fig1_output_path_svg = os.path.join(
        output_dir, fig1_output_name.replace(".png", ".svg")
    )

    fig1.savefig(fig1_output_path_png, format="png", bbox_inches="tight")
    fig1.savefig(fig1_output_path_svg, format="svg", bbox_inches="tight")
    print(
        f"Nodes and Edges plots saved to {fig1_output_path_png} and {fig1_output_path_svg}"
    )
    plt.close(fig1)  # Close the figure to free memory

    # --- Plotting Communities, Degree, Modularity, Clustering Coefficient ---
    metrics_other = [
        "Number_communities",
        "Avg_degree",
        "Modularity",
        "Avg_clustering_coefficient",
    ]
    metric_name_mapping_other = {
        "Number_communities": "Number of Communities",
        "Avg_degree": "Average Degree",
        "Modularity": "Modularity",
        "Avg_clustering_coefficient": "Average Clustering Coefficient",
    }

    # Metrics for which y-axis should be formatted to 2 decimal places
    metrics_needing_float_formatting = [
        "Modularity",
        "Avg_degree",
        "Avg_clustering_coefficient",
    ]

    for col in metrics_needing_float_formatting:
        if col in filtered_metrics.columns:
            filtered_metrics[col] = pd.to_numeric(
                filtered_metrics[col], errors="coerce"
            )

    fig2, axes2 = plt.subplots(nrows=2, ncols=2, figsize=(20, 15))

    for i, metric in enumerate(metrics_other):
        ax = axes2.flatten()[i]
        for biome in filtered_metrics["Biome"].unique():
            sns.lineplot(
                ax=ax,
                x="Threshold",
                y=metric,
                data=filtered_metrics[filtered_metrics["Biome"] == biome],
                marker="o",
                markersize=9,
                linewidth=2.5,
                color=(
                    palette[filtered_metrics["Biome"].unique().tolist().index(biome)]
                    if len(palette) > 1
                    else palette[0]
                ),
            )
        ax.set_ylabel(metric_name_mapping_other[metric], fontsize=axis_label_font_size)
        # Only add x-label to bottom row plots
        ax.set_xlabel(
            "Association Threshold" if i >= (len(metrics_other) / 2) else "",
            fontsize=axis_label_font_size,
        )
        ax.tick_params(axis="both", labelsize=tick_label_font_size)
        ax.set_xticks(x_ticks)

        # Apply float formatting for specific metrics
        if metric in metrics_needing_float_formatting:
            ax.yaxis.set_major_formatter(ticker.FormatStrFormatter("%.2f"))

    # Creating legend handles for other metrics plot
    legend_handles_2 = []
    for biome in filtered_metrics["Biome"].unique():
        line = plt.Line2D(
            [],
            [],
            color=(
                palette[filtered_metrics["Biome"].unique().tolist().index(biome)]
                if len(palette) > 1
                else palette[0]
            ),
            marker="o",
            markersize=10,
            linestyle="-",
            linewidth=3,
            label=biome,
        )
        legend_handles_2.append(line)

    fig2.legend(
        handles=legend_handles_2,
        loc="upper center",
        title="Biome",
        ncol=len(filtered_metrics["Biome"].unique()),
        bbox_to_anchor=(0.5, 0.98),
        fontsize=legend_font_size,
        title_fontproperties=title_font,
    )

    plt.tight_layout(rect=[0, 0, 1, 0.95])  # Adjusted rect to make space for title

    # Saving the other metrics plots - filenames now rely only on dataset_name
    fig2_output_name = f"{dataset_name}_metrics_plots.png"
    fig2_output_path_png = os.path.join(output_dir, fig2_output_name)
    fig2_output_path_svg = os.path.join(
        output_dir, fig2_output_name.replace(".png", ".svg")
    )

    fig2.savefig(fig2_output_path_png, format="png", bbox_inches="tight")
    fig2.savefig(fig2_output_path_svg, format="svg", bbox_inches="tight")
    print(
        f"Other metrics plots saved to {fig2_output_path_png} and {fig2_output_path_svg}"
    )
    plt.close(fig2)  # Close the figure to free memory


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Generate plots for network topological metrics across thresholds."
    )
    parser.add_argument(
        "--input_file",
        type=str,
        required=True,
        help="Path to the CSV file containing network metrics (output from the analysis script).",
    )
    parser.add_argument(
        "--output_dir",
        type=str,
        default="../../Output/Threshold_analysis/Plots",
        help="Directory where the generated plots (PNG and SVG) will be saved.",
    )
    parser.add_argument(
        "--dataset_name",
        type=str,
        required=True,
        help="Name of the dataset/biome (e.g., 'NOPGE_sp_01_asso') for output file naming. "
        "This name should implicitly contain information about network type and weight column "
        "if those distinctions are needed in the plot filenames.",
    )

    args = parser.parse_args()

    # Load the DataFrame
    if not os.path.exists(args.input_file):
        raise FileNotFoundError(f"Input file not found: {args.input_file}")

    # Use try-except for robust CSV loading
    try:
        clust_metrics_df = pd.read_csv(args.input_file)
    except Exception as e:
        raise ValueError(f"Error loading input CSV file {args.input_file}: {e}")

    # Generate and save plots
    generate_plots(clust_metrics_df, args.output_dir, args.dataset_name)
